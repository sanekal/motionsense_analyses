---
title: "MotionSense Dataset Analyses"
author: "Sam Anekal"
date: "9/23/2019"
output: html_document
---

Setup knitr with global options.  

```{r setup}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, include = TRUE, message = FALSE)
```

## Background

This is a simple set of analyses on the MotionSense Dataset uploaded by M. Malekzadeh (https://github.com/mmalekzadeh/motion-sense). The dataset contains time-series data generated by accelerometer and gyroscope sensors by an iPhone 6s kept in the front pocket of 24 participants, who perform 6 different activities in 15 trials in the same environment under the same conditions. 

There are 9 long trials (1 through 9) with 2-3 minute duration and 6 short trials (11 - 16) with 30s-1min duration. There are 24 subjects performing 6 activities in different environments: downstairs (dws), upstairs (ups), sitting (sit), standing (std), walking (wlk), and jogging (jog).

Each datafile contains a list of 12 features which are outputs from the accelerometer and gyroscope which are outputs from the CMDeviceMotion class - attitude.roll, attitude.pitch, attitude.yaw, gravity.x, gravity.y, gravity.z, rotationRate.x, rotationRate.y, rotationRate.z, userAcceleration.x, userAcceleration.y, userAcceleration.z. 

The following examples illustrate useful information which can be extracted from this dataset. Specifically, we will look into how different features extracted from the time-series data vary with activity.


```{r include libraries, echo=TRUE}
rm(list=ls())
library(tidyverse)
library(psd)
```

Set working directory and set paths for data files.

```{r set working directory and paths, echo=TRUE}

#specify paths to subject info file and folder containing time-series datasets
subject_info_path = 'data_subjects_info.csv'
data_folder_path = './A_DeviceMotion_data'
```

Read file containing subject info. Also, read in a time-series data file at random to visualize output

```{r read files, echo=TRUE, fig.width = 9.0, fig.height = 7.0}
#read file containing subject information
subject_info_df = read_csv(subject_info_path)

#read a sample file to visualize data by sampling a file, reading its contents, and plotting it
file_list = list.files(data_folder_path, recursive = TRUE, full.names = TRUE)
sample_file = sample(file_list[grepl('wlk_', file_list, fixed = FALSE)], size=1)
sample_df = read_csv(sample_file, col_names = TRUE, col_types = cols())
sample_df_gathered = sample_df %>% gather(-1, key='measurand', value='value') %>% rename('time'='X1')
p_sample = ggplot(data=sample_df_gathered, aes(x=time, y=value)) + geom_line() + facet_grid(measurand~., labeller = labeller(measurand = label_wrap_gen(8)))
print(p_sample)
```

The sample plot shows characteristics which are typical of periodic time-series data. Repeating patterns are seen at regular intervals. Some of the components such as gravity and attitude are featureless, indicating little force or orientation change for this particular activity. This type of data is best analyzed in Fourier space, where dominant frequencies and corresponding amplitudes can be extracted. This also allows one to significantly compress the dataset by only retaining the dominant frequency modes.

In what follows, a function is written to extract the 100 most dominant Fourier modes of all 360 data files, and combine them into a single data frame for further analysis. For each data file, the associated activity label, activity id (label combined with trial number) and subject code are attached.

```{r extract Fourier modes, echo=TRUE}
#function to extract data from all datafiles listed in teh datafolder
extract_all_data = function(main_folder=data_folder_path, subject_info=subject_info_df){
  #get list of all activity codes by reading the sub-folder names and extracting the relevant bits of sub-folder names
  sub_folder_list = list.files(main_folder)
  activity_list = unique(as.character(sapply(sub_folder_list, function(x) strsplit(x, split='_')[[1]][1])))
  
  #read subject information file to get list of subject codes
  subj_id_list = paste0('sub_', subject_info$code)
  
  #get path for all data files
  file_list = list.files(main_folder, recursive = TRUE, full.names = TRUE)
  
  #extract data for specified file
  extract_data = function(file_path, activities = activity_list){
    #extract subject id from file path
    subj_id = str_extract(file_path, 'sub_\\d*')
    
    #extract activity category and activity id. also, create a new logical variable called duration to identify length of trial (long or short)
    #duration is TRUE if trial id > 9 and FALSE otherwise 
    activity = unlist(str_match_all(file_path, activities))
    activity_id = str_extract(file_path, paste0(activity, '_\\d*'))
    duration = as.numeric(strsplit(activity_id, '_')[[1]][2])>9
    
    #read column names in data file
    ip_df = read_csv(file_path, col_names=TRUE, col_types = cols()) %>% rename('time' = 'X1')
    col_name_list = colnames(ip_df)[-1] #only select response variable for transformation
    
    #extract 10 most dominant spectral modes for each measurand
    calc_spectral_modes = function(col_no, ip_df){
      #extract vector for particular measurand
      tmp = ip_df[,col_no]
      measurand_name = colnames(tmp)
      signal_vec = pull(tmp, measurand_name)
      
      #calculate power spectral density after mean subtraction
      psd = pspectrum(signal_vec-mean(signal_vec), verbose=FALSE)
      dum = data.frame(freq=psd$freq, power=psd$spec) 
      dum = dum %>% mutate_all(~if_else(is.na(.), 0, .)) 
      #arrange data frame in decreasing order of power, and select the first 10 components. attach measurand name to this data frame
      dum = dum %>% arrange(desc(.[[2]])) %>% slice(1:100) %>% mutate(measurand=measurand_name)
      return(dum)
    }
    
    #for this current data file, extract fourier modes for all measurands
    op_df = lapply(seq(2,ncol(ip_df)), calc_spectral_modes, ip_df) %>% bind_rows()
    #attach activity, activity id, and duration labels
    op_df = op_df %>% mutate(code = as.numeric(strsplit(subj_id, '_')[[1]][2]), activity = activity, activity_id = activity_id, duration = duration)
    return(op_df)
  }
  #extract all data files as described above
  data_df = lapply(file_list, extract_data) %>% bind_rows()
  return(data_df)
}
```


This function extracts Fourier components of individual data files, compresses and aggregates into a single data file. This function is now called to process all data files and create a master data frame. This data frame is written to a file for further use.

```{r read data files, echo=TRUE}
#check if data has been extracted - if yes, read extracted data; if not extract data and save extracted data file
if(file.exists('data_extracted_fs.csv')){
  ip_df = read_csv('data_extracted_fs.csv', col_names=TRUE, col_types = cols())
} else {
  ip_df = extract_all_data()
  write.csv(ip_df, 'data_extracted_fs.csv')
}

#combine extracted data with information on each subject by using SQL-type inner join
full_data_df = inner_join(ip_df[,-1], subject_info_df, by='code')

#look at first few rows of data frame
head(full_data_df)
```

Information from all data files have been aggregated into a compact data frame. This data frame is organized in a way to use dplyr's various data wrangling tools, as well as visualize using ggplot. Some examples are illustrated below.

```{r visualization examples, echo=TRUE, fig.width = 10, fig.height = 5.0}
#extract all data for subject 1 where activity performed was walking or jogging. 
subj_1_df = filter(full_data_df, code==1, activity %in% c('jog', 'wlk'))

#look at first few rows
head(subj_1_df)

#visualize the rotational components for this particular dataset and separate across different trials. Also identify difference between durations
p1 = ggplot(data=filter(subj_1_df, grepl('rotation', measurand)), aes(x=freq, y=power, color=factor(duration))) + theme_grey(12) + geom_line() + facet_grid(measurand~activity_id) + scale_x_continuous('Frequency', breaks = seq(0,0.5,0.1)) + scale_y_log10('Power') + labs(color = 'duration')
print(p1)
```

It is easy to see that walking and jogging show very similar frequency characteristics for rotational components. Let's try another example where we extract the dominant frequency for all subjects across all trials and plot a histogram of the dominant frequency for rotation and acceleration separated by activity type

```{r plot dominant freq histogram, echo=TRUE, fig.width = 10, fig.height = 5.0}
dominant_freq_df = full_data_df %>% group_by_at(vars(-freq, -power)) %>% filter(power==max(power)) %>% rename()

p2 = ggplot(data=filter(dominant_freq_df, grepl('rotation', measurand) | grepl('Acceleration', measurand)), aes(x=freq)) + theme_grey(12) + geom_histogram(aes(fill=factor(duration)), bins=25) + facet_grid(activity~measurand, labeller = labeller(measurand = label_wrap_gen(15))) + theme_grey(12) + scale_x_continuous('Dominant Frequency', breaks=seq(0,0.5,0.1)) + scale_y_continuous('Count') + labs(color = 'duration')
print(p2)
```


It can be qualitatively seen that the dominant frequency distributions are similar for the following pairs: dws/ups, sit/std, wlk/jog. With the data organized in a convenient data frame, all permutations are easily accessible with limited lines of code. As a grand finale, the entire data frame is visualized by plotting a 2d density of frequency and power as a function of all measurands and activities. 

```{r grand finale plot, echo=TRUE, fig.width = 10, fig.height = 7.0}
p_hist = ggplot(data=full_data_df) + theme_grey(10) + stat_density_2d(aes(x=freq, y=log10(power), fill=..density..), geom='raster', contour=FALSE) + scale_fill_distiller(palette='Spectral', trans='log', direction=1) + scale_x_continuous('Frequency', expand = c(0, 0), breaks=seq(0,0.5,0.25)) + scale_y_continuous('Log(Power)', expand = c(0, 0), breaks = seq(-7.5,2.5,5)) + theme(legend.position='none') + facet_grid(activity~measurand, labeller = labeller(measurand = label_wrap_gen(0.5), multi_line = TRUE))
print(p_hist)
```


The previous plot is an illustration of the ease with which complex, multi-dimensional information can be summarized in a single plot. The purpose of these density plots is more qualitative. For example, it can be clearly seen that there is a very narrow range few frequencies for gravity and attitude vectors for "sit" and "std" activities, which intuitively makes sense because the position, both with respect the phone's reference system and gravity are constant. The similarities between dws/ups, sit/std, wlk/jog are evident in this plot as well.

In the next section, the data frame is analyzed to more formally identify variables which are significant in describing specific activities.

```{r glm fit, echo=TRUE, , fig.width = 7.0, fig.height = 7.0}
#extract a subset of dataset for subject #10 (code = 10), and filter out datasets with long duration (duration = TRUE)
#also, add an index to the first column to indicate the fourier mode. this will be used for the generalized linear model
fit_df = full_data_df %>% mutate(X1 = rep(seq(1,100), 4320)) %>% filter(duration, code == 10)

#construct a generalized linear model to predict activity type as a function of the frequency mode, frequency, and power separated by the categorical variable "measurand". Note that a mixed-effect term freq*power is added to capture the dependency on the product of the spectral model and its amplitude. 
glmmod = glm(factor(activity) ~ X1 + factor(measurand) + freq*power, data = fit_df, family = binomial(link='logit'))

#view model results
print(summary(glmmod))

#print only significant variables
coeff_list = summary(glmmod)$coeff
print(coeff_list[coeff_list[,4]<0.05,])
```

From the regression results, we obtain the value and significance of various independent variables. By screening coefficients which show a p-value of <0.05, we obtain a list of variables which can explain most of the variance in the data - for the selected activity (jogging), the orientation given by roll and yaw are the most relevant; acceleration in x and y are significant (compared to z, which is not), and rotation rates in all three directions are significant. 